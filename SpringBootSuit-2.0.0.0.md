1.  springboot が起動すると、データベースに権限関連のテーブルが存在するかどうかを判断し、存在しない場合は、権限用のテーブルを自動的に作成。

2.  sf 定義を利用して権限設定内容を自動エクスポートし、Spring Boot 起動後、saasforceに既に登録されているユーザーでログインできるようにする。

3.  共通関数設計書は、Spring Boot のデータ操作コードを作成できます。基本的なinsert、delete、update、selectではなく、複雑なinsert select 、複数のテーブルのupate、複数のテーブルのdelete、およびサブクエリを含むselect sqlを実行するコードの作成が実現。

4.  フロントエンドとバックエンドのパラメータ取得は、requestのオブジェクトをserviceに引き渡さない、コントローラー層でreqestMappingでデータを取得し、データは自動的にentityに引き渡し、その後の操作はentityを使用して処理する。 .

5.  Validatorは専用のフレームワーク spring-boot-starter-validationを採用、

6.  構成に Springboot で yml 形式を使用
  yml 形式の構成ファイルには、次のメリット: 
  6.1. 大文字と小文字が区別される 
  6.2. インデントを使用して階層関係を表す 
  6.3. インデントの長さに制限がない
    要素が整列されている限り、これらの要素は同じレベル 4 に属していることを意味する
  6.4. # を使用してコメントを示す

7.  Springboot に準拠した標準の起動メソッドに変換し、MapperScan アノテーションを削除

8.  SpringBoot の Aspect アスペクトを使用してログを出力する方式に変更
　Aspect定義に準拠するメソッド (全Service サフィックスを持つクラス内のメソッドなど) をエントリ ポイントとして作成する。
　メリットは、ハード コーディングがない、より簡潔なコード、より柔軟な変更、および簡単な拡張。

9.  トランザクションのロールバックを伴わない例外は、サービス層で処理されます。 Springboot フレームワークによって提供される @ControllerAdvice アノテーションを使用して、コントローラー レイヤーの機能強化を実現することで、プロジェクトのすべての処理からスローされた例外をキャプチャして処理することが可能.

10. 複数のテーブルを含む読み取りと書き込みを行う場合は、Springboot の宣言型トランザクション アノテーションを使用

11. すべての単体テストの基本クラスとして BaseTest を作成する。
　@RunWith(SpringRunner.class)
　@SpringBootTest(classes = Application.class) これらの 2 つの注釈を利用

12. Mapper は、Java コードと分離し、リソース ディレクトリに個別に格納。

13. Springboot＋MybatisのSQL文出力に関してLog4jのクラスを拡張して、SQL処理時間を出力するようにする

14. ログイン インターセプターを追加し、ログインが必要なコントローラーを自動的にインターセプトする
